syntax = "proto3";

package modbustohttp.v1alpha1;

option go_package = "modbustohttp/gen/modbustohttp/v1alpha1";

import "buf/validate/validate.proto";


// ModbusService translates the modbus.Client interface to RPC here: https://pkg.go.dev/github.com/goburrow/modbus#Client
// Implementation guided by the documentation of the Modbus protocol here: https://www.modbustools.com/modbus.html
service ModbusService {
  rpc ReadHoldingRegisters(ReadHoldingRegistersRequest) returns (ReadHoldingRegistersResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  };

  rpc WriteSingleRegister(WriteSingleRegisterRequest) returns (WriteSingleRegisterResponse) {
    option idempotency_level = IDEMPOTENT;
  };
  rpc ReadCoils(ReadCoilsRequest) returns (ReadCoilsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  };
  rpc ReadDiscreteInputs(ReadDiscreteInputsRequest) returns (ReadDiscreteInputsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  };
  rpc WriteSingleCoil(WriteSingleCoilRequest) returns (WriteSingleCoilResponse) {
    option idempotency_level = IDEMPOTENT;
  }
  rpc WriteMultipleCoils(WriteMultipleCoilsRequest) returns (WriteMultipleCoilsResponse) {
    option idempotency_level = IDEMPOTENT;
  }
  rpc ReadInputRegisters(ReadInputRegistersRequest) returns (ReadInputRegistersResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  };
  rpc WriteMultipleRegisters(WriteMultipleRegistersRequest) returns (WriteMultipleRegistersResponse) {
    option idempotency_level = IDEMPOTENT;
  }
  rpc MaskWriteRegister(MaskWriteRegisterRequest) returns (MaskWriteRegisterResponse) {
    option idempotency_level = IDEMPOTENT;
  };
}

message ReadInputRegistersRequest {
  // The address start start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  // The quantity of registers to read start from address
  optional uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=125,(buf.validate.field).uint32.gt=0
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadInputRegistersResponse {
  // The values of the registers read
  repeated Register registers = 1 [
    (buf.validate.field).repeated.min_items=1,(buf.validate.field).repeated.max_items=125
  ];
}

message ReadHoldingRegistersRequest {
  // The address start start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  // The quantity of registers to read start from address
  optional uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=125,(buf.validate.field).uint32.gt=0
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadHoldingRegistersResponse {
  // The values of the registers read
  repeated Register registers = 1 [
    (buf.validate.field).repeated.min_items=1,(buf.validate.field).repeated.max_items=125
  ];
}

message WriteSingleRegisterRequest {
  // The register to write
  Register register = 2;
}

message WriteSingleRegisterResponse {}

message ReadCoilsRequest {
  // The address to start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte=65535,
    (buf.validate.field).uint32.gte=0
  ];
  // The quantity of registers to read starting from address
  uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=2000,
    (buf.validate.field).uint32.gte=1
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadCoilsResponse {
  repeated BooleanAddress coils = 1 [
    (buf.validate.field).repeated.min_items=1,
    (buf.validate.field).repeated.max_items=2000
  ];
}

message ReadDiscreteInputsRequest {
  // The address to start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte=65535,
    (buf.validate.field).uint32.gte=0
  ];
  // The quantity of registers to read starting from address
  uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=2000,
    (buf.validate.field).uint32.gte=1
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadDiscreteInputsResponse {
  repeated BooleanAddress inputs = 1 [
    (buf.validate.field).repeated.min_items=1,
    (buf.validate.field).repeated.max_items=2000
  ];
}

message WriteSingleCoilRequest {
  BooleanAddress coil = 1;
}

message WriteSingleCoilResponse {}

message WriteMultipleCoilsRequest {
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535,
    (buf.validate.field).uint32.gte = 0
  ];
  repeated bool values = 2;
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + length of values must not be greater than 65536"
    expression: "this.address + uint(this.values.size()) <= 65536"
  };
}

message WriteMultipleCoilsResponse {}

message WriteMultipleRegistersRequest {
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  repeated uint32 values = 2 [
    (buf.validate.field).repeated.min_items=1,(buf.validate.field).repeated.max_items=123
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + length of values must not be greater than 65536"
    expression: "this.address + uint(this.values.size()) <= 65536"
  };
}

message WriteMultipleRegistersResponse {}

message MaskWriteRegisterRequest {
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  option (buf.validate.message).oneof = { fields: ["int_and_mask", "bit_and_mask"], required: true };
  uint32 int_and_mask = 2 [
    (buf.validate.field).uint32.gte=0, (buf.validate.field).uint32.lte=65535
  ];
  RegisterBitMask bit_and_mask = 3;
  option (buf.validate.message).oneof = { fields: ["int_or_mask", "bit_or_mask"], required: true };
  uint32 int_or_mask = 4 [
    (buf.validate.field).uint32.gte=0, (buf.validate.field).uint32.lte=65535
  ];
  RegisterBitMask bit_or_mask = 5;
}

message MaskWriteRegisterResponse {}

message RegisterBitMask {
  repeated bool bits = 1 [
    (buf.validate.field).repeated.min_items=16, (buf.validate.field).repeated.max_items=16
  ];
}

message BooleanAddress {
  // The address of the coil or discrete input
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535,
    (buf.validate.field).uint32.gte = 0
  ];
  // The value of the coil or discrete input
  bool value = 2;
}


// A modbus register value
message Register {
  // The address of the register
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  // The value of the register
  uint32 value = 2 [
    (buf.validate.field).uint32.gte = 0, (buf.validate.field).uint32.lte = 65535
  ];
}