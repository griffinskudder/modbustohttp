syntax = "proto3";

package modbustohttp.v1alpha1;

option go_package = "modbustohttp/gen/modbustohttp/v1alpha1";

import "buf/validate/validate.proto";


// ModbusService translates the modbus.Client interface to RPC here: https://pkg.go.dev/github.com/goburrow/modbus#Client
service ModbusService {
  rpc ReadHoldingRegisters(ReadHoldingRegistersRequest) returns (ReadHoldingRegistersResponse);
  rpc WriteSingleRegister(WriteSingleRegisterRequest) returns (WriteSingleRegisterResponse);
  rpc ReadCoils(ReadCoilsRequest) returns (ReadCoilsResponse);
  rpc ReadDiscreteInputs(ReadDiscreteInputsRequest) returns (ReadDiscreteInputsResponse);
}

message ReadHoldingRegistersRequest {
  // The address start start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  // The quantity of registers to read start from address
  optional uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=125,(buf.validate.field).uint32.gt=0
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadHoldingRegistersResponse {
  // The values of the registers read
  repeated Register registers = 1 [
    (buf.validate.field).repeated.min_items=1,(buf.validate.field).repeated.max_items=125
  ];
}

message WriteSingleRegisterRequest {
  // The register to write
  Register register = 2;
}

message WriteSingleRegisterResponse {}

message ReadCoilsRequest {
  // The address to start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte=65535,
    (buf.validate.field).uint32.gte=0
  ];
  // The quantity of registers to read starting from address
  uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=2000,
    (buf.validate.field).uint32.gte=1
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadCoilsResponse {
  repeated BooleanAddress coils = 1 [
    (buf.validate.field).repeated.min_items=1,
    (buf.validate.field).repeated.max_items=2000
  ];
}

message ReadDiscreteInputsRequest {
  // The address to start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte=65535,
    (buf.validate.field).uint32.gte=0
  ];
  // The quantity of registers to read starting from address
  uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=2000,
    (buf.validate.field).uint32.gte=1
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadDiscreteInputsResponse {
  repeated BooleanAddress inputs = 1 [
    (buf.validate.field).repeated.min_items=1,
    (buf.validate.field).repeated.max_items=2000
  ];
}

message BooleanAddress {
  // The address of the coil or discrete input
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535,
    (buf.validate.field).uint32.gte = 0
  ];
  // The value of the coil or discrete input
  bool value = 2;
}


// A modbus register value
message Register {
  // The address of the register
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  // The value of the register
  uint32 value = 2 [
    (buf.validate.field).uint32.gte = 0, (buf.validate.field).uint32.lte = 65535
  ];
}