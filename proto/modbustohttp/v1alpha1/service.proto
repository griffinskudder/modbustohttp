syntax = "proto3";

package modbustohttp.v1alpha1;

option go_package = "modbustohttp/service/modbustohttp/v1alpha1";

import "modbustohttp/v1alpha1/types.proto";

import "buf/validate/validate.proto";


// ModbusService translates the modbus.Client interface to RPC here: https://pkg.go.dev/github.com/goburrow/modbus#Client
// Implementation guided by the documentation of the Modbus protocol here: https://www.modbustools.com/modbus.html
service ModbusService {
  // ReadHoldingRegisters reads the holding registers from the modbus server
  rpc ReadHoldingRegisters(ReadHoldingRegistersRequest) returns (ReadHoldingRegistersResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  };
  // WriteSingleRegister writes a single holding register to the modbus server
  rpc WriteSingleRegister(WriteSingleRegisterRequest) returns (WriteSingleRegisterResponse) {
    option idempotency_level = IDEMPOTENT;
  };
  // ReadCoils reads the coils from the modbus server
  rpc ReadCoils(ReadCoilsRequest) returns (ReadCoilsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  };
  // ReadDiscreteInputs reads the discrete inputs from the modbus server
  rpc ReadDiscreteInputs(ReadDiscreteInputsRequest) returns (ReadDiscreteInputsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  };
  // WriteSingleCoil writes a single coil to the modbus server
  rpc WriteSingleCoil(WriteSingleCoilRequest) returns (WriteSingleCoilResponse) {
    option idempotency_level = IDEMPOTENT;
  }
  // WriteMultipleCoils writes multiple coils to the modbus server
  rpc WriteMultipleCoils(WriteMultipleCoilsRequest) returns (WriteMultipleCoilsResponse) {
    option idempotency_level = IDEMPOTENT;
  }
  // ReadInputRegisters reads the input registers from the modbus server
  rpc ReadInputRegisters(ReadInputRegistersRequest) returns (ReadInputRegistersResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  };
  // WriteMultipleRegisters writes multiple holding registers to the modbus server
  rpc WriteMultipleRegisters(WriteMultipleRegistersRequest) returns (WriteMultipleRegistersResponse) {
    option idempotency_level = IDEMPOTENT;
  }
  // WriteBitInRegister writes a single bit in a holding register to the modbus server
  rpc WriteBitInRegister(WriteBitInRegisterRequest) returns (WriteBitInRegisterResponse) {};
}

message ReadInputRegistersRequest {
  // The address start start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  // The quantity of registers to read start from address
  optional uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=125,(buf.validate.field).uint32.gt=0
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadInputRegistersResponse {
  // The values of the registers read
  repeated Register registers = 1 [
    (buf.validate.field).repeated.min_items=1,(buf.validate.field).repeated.max_items=125
  ];
}

message ReadHoldingRegistersRequest {
  // The address start start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  // The quantity of registers to read start from address
  optional uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=125,(buf.validate.field).uint32.gt=0
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadHoldingRegistersResponse {
  // The values of the registers read
  repeated Register registers = 1 [
    (buf.validate.field).repeated.min_items=1,(buf.validate.field).repeated.max_items=125
  ];
}

message WriteSingleRegisterRequest {
  // The register to write
  Register register = 2;
}

message WriteSingleRegisterResponse {}

message ReadCoilsRequest {
  // The address to start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte=65535,
    (buf.validate.field).uint32.gte=0
  ];
  // The quantity of registers to read starting from address
  uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=2000,
    (buf.validate.field).uint32.gte=1
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadCoilsResponse {
  repeated BooleanAddress coils = 1 [
    (buf.validate.field).repeated.min_items=1,
    (buf.validate.field).repeated.max_items=2000
  ];
}

message ReadDiscreteInputsRequest {
  // The address to start reading from
  uint32 address = 1 [
    (buf.validate.field).uint32.lte=65535,
    (buf.validate.field).uint32.gte=0
  ];
  // The quantity of registers to read starting from address
  uint32 quantity = 2 [
    (buf.validate.field).uint32.lte=2000,
    (buf.validate.field).uint32.gte=1
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + quantity must not be greater than 65536"
    expression: "this.address + this.quantity <= 65536"
  };
}

message ReadDiscreteInputsResponse {
  repeated BooleanAddress inputs = 1 [
    (buf.validate.field).repeated.min_items=1,
    (buf.validate.field).repeated.max_items=2000
  ];
}

message WriteSingleCoilRequest {
  BooleanAddress coil = 1;
}

message WriteSingleCoilResponse {}

message WriteMultipleCoilsRequest {
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535,
    (buf.validate.field).uint32.gte = 0
  ];
  repeated bool values = 2;
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + length of values must not be greater than 65536"
    expression: "this.address + uint(this.values.size()) <= 65536"
  };
}

message WriteMultipleCoilsResponse {}

message WriteMultipleRegistersRequest {
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  repeated uint32 values = 2 [
    (buf.validate.field).repeated.min_items=1,(buf.validate.field).repeated.max_items=123
  ];
  option (buf.validate.message).cel = {
    id: "not.out.of.range"
    message: "address + length of values must not be greater than 65536"
    expression: "this.address + uint(this.values.size()) <= 65536"
  };
}

message WriteMultipleRegistersResponse {}

message WriteBitInRegisterRequest {
  // The address of the register
  uint32 address = 1 [
    (buf.validate.field).uint32.lte = 65535
  ];
  // The bit to write in the register (0-15)
  uint32 bit = 2 [
    (buf.validate.field).uint32.lte = 15,
    (buf.validate.field).uint32.gte = 0
  ];
  // The value of the bit to write
  bool value = 3;
}

message WriteBitInRegisterResponse {}